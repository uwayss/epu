import { promises as fs } from "fs";
import path from "path";
import process from "process"; // Required for process.cwd() and process.env

async function generateFileDump(
  projectRoot,
  outputFile,
  targetFolder,
  includeNatives
) {
  const defaultExcludeDirs = new Set([
    ".git",
    "__pycache__",
    "node_modules",
    ".expo",
    ".yarn",
    "coverage",
    "build",
    ".gradle",
    ".idea",
    ".cxx",
    "xcuserdata",
    "DerivedData",
    "Pods",
    "fastlane",
    "bundle",
    "ios",
    "android",
    "codebase",
    "assets",
    ".github",
  ]);

  const defaultExcludeFiles = new Set([
    "package-lock.json",
    "pnpm-lock.yaml",
    "bun.lockb",
    ".DS_Store",
    "local.properties",
    ".xcode.env.local",
    "npm-debug.log",
    "yarn-error.log",
    ".metro-health-check",
  ]);

  const defaultExcludeExtensions = new Set([
    ".apk",
    ".aar",
    ".jar",
    ".keystore",
    ".jks",
    ".hprof",
    ".iml",
    ".pbxuser",
    ".mode1v3",
    ".mode2v3",
    ".perspectivev3",
    ".xccheckout",
    ".moved-aside",
    ".hmap",
    ".ipa",
    ".xcuserstate",
    ".jsbundle",
    ".wasm",
    ".dat",
    ".bin",
    ".db",
    ".sqlite",
    ".obj",
    ".pdb",
    ".tlog",
    ".lib",
    ".exp",
    ".dll",
    ".so",
    ".dylib",
    ".class",
    ".dex",
    ".gradle-build",
    ".log",
    ".lock",
    ".png",
    ".jpg",
    ".jpeg",
    ".gif",
    ".bmp",
    ".tiff",
    ".ico",
    ".webp",
    ".heic",
    ".mp3",
    ".wav",
    ".ogg",
    ".flac",
    ".aac",
    ".mp4",
    ".mov",
    ".avi",
    ".wmv",
    ".mkv",
    ".webm",
    ".ttf",
    ".otf",
    ".woff",
    ".woff2",
    ".zip",
    ".tar",
    ".gz",
    ".rar",
    ".7z",
    ".bz2",
    ".xz",
    ".pdf",
    ".doc",
    ".docx",
    ".xls",
    ".xlsx",
    ".ppt",
    ".pptx",
    ".psd",
    ".ai",
    ".indd",
    ".exe",
    ".dmg",
    ".app",
  ]);

  const excludeDirs = new Set(defaultExcludeDirs);
  if (includeNatives) {
    excludeDirs.delete("ios");
    excludeDirs.delete("android");
  }

  const excludeFiles = new Set(defaultExcludeFiles);
  const excludeExtensions = new Set(defaultExcludeExtensions);

  let outputContent = `// AUTOGENERATED CODEBASE DUMP\n`;
  outputContent += `// Project Root: ${projectRoot}\n`;
  if (targetFolder) {
    outputContent += `// Target Folder: ${targetFolder}\n\n`;
  } else {
    outputContent += `// Target Folder: All\n\n`;
  }

  async function walk(currentDir) {
    const entries = await fs.readdir(currentDir, { withFileTypes: true });

    for (const entry of entries) {
      const entryPath = path.join(currentDir, entry.name);
      const relativePath = path.relative(projectRoot, entryPath);
      const parts = relativePath.split(path.sep);

      if (entry.isDirectory()) {
        if (!parts.some((part) => excludeDirs.has(part))) {
          // If targetFolder is specified, only walk into it or its subdirectories.
          // If no targetFolder, walk everything not excluded.
          if (
            !targetFolder ||
            relativePath.startsWith(targetFolder) ||
            targetFolder.startsWith(relativePath)
          ) {
            await walk(entryPath);
          }
        }
      } else if (entry.isFile()) {
        const fileExtension = path.extname(entry.name).toLowerCase();
        if (
          (!parts.some((part) => excludeDirs.has(part)) ||
            (includeNatives &&
              (parts[0] === "ios" || parts[0] === "android"))) &&
          !excludeFiles.has(entry.name) &&
          !excludeExtensions.has(fileExtension)
        ) {
          // If targetFolder is specified, ensure the file is within that folder.
          if (!targetFolder || relativePath.startsWith(targetFolder)) {
            try {
              const content = await fs.readFile(entryPath, "utf-8");
              outputContent += `\n// FILE: ${relativePath}\n`;
              outputContent += content + "\n";
            } catch (error) {
              if (
                error.code === "ERR_INVALID_ARG_VALUE" ||
                error.code === "ERR_BUFFER_TOO_LARGE"
              ) {
                outputContent += `\n// FILE: ${relativePath} (Skipped due to unreadable content or size limit)\n`;
              } else {
                outputContent += `\n// ERROR READING ${relativePath}: ${error.message}\n`;
              }
            }
          }
        }
      }
    }
  }

  const resolvedProjectRoot = path.resolve(projectRoot);
  let startWalkDir = resolvedProjectRoot;

  if (targetFolder) {
    const targetPath = path.join(resolvedProjectRoot, targetFolder);
    try {
      const stats = await fs.stat(targetPath);
      if (!stats.isDirectory()) {
        console.error(
          `Error: Target folder '${targetFolder}' not found or is not a directory in project root.`
        );
        return;
      }
      startWalkDir = targetPath; // Start walking from the target folder
    } catch (err) {
      console.error(
        `Error: Target folder '${targetFolder}' not found or inaccessible: ${err.message}`
      );
      return;
    }
  }

  await walk(startWalkDir);

  try {
    await fs.writeFile(outputFile, outputContent, "utf-8");
    console.log(`Codebase dump created: ${path.resolve(outputFile)}`);
  } catch (error) {
    console.error(`Error writing to output file: ${error}`);
  }
}

async function executeDump(projectRoot, targetFolder, includeNatives) {
  const desktopDir = path.join(
    process.env.HOME ||
      process.env.USERPROFILE ||
      process.env.HOMEPATH ||
      os.tmpdir(), // Fallback to tmpdir
    "Desktop"
  );
  try {
    await fs.mkdir(desktopDir, { recursive: true }); // Ensure desktop directory exists
  } catch (e) {
    console.warn(
      `Warning: Could not create/access Desktop directory at ${desktopDir}. Files will be saved in project root. Error: ${e.message}`
    );
    // Fallback to project root if desktop is not accessible
    const fallbackDir = path.join(projectRoot, "codebase_dumps");
    await fs.mkdir(fallbackDir, { recursive: true });
    // Not reassigning desktopDir, generateFileDump will handle the output path fully
  }

  const parentFolderName = path.basename(projectRoot);
  const timestamp = new Date()
    .toLocaleTimeString("en-US", {
      hour12: false,
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
    })
    .replace(/:/g, "");
  const outputFilename = `${parentFolderName}_${timestamp}_dump.txt`;

  let outputFile;
  try {
    // Attempt to use Desktop directory
    await fs.access(desktopDir, fs.constants.W_OK);
    outputFile = path.join(desktopDir, outputFilename);
  } catch (error) {
    // Fallback to a 'codebase_dumps' subdirectory in the project root
    console.warn(
      `Desktop directory not writable. Saving dump to project's 'codebase_dumps' folder.`
    );
    const fallbackDir = path.join(projectRoot, "codebase_dumps");
    await fs.mkdir(fallbackDir, { recursive: true });
    outputFile = path.join(fallbackDir, outputFilename);
  }

  await generateFileDump(projectRoot, outputFile, targetFolder, includeNatives);
}

export function register(program) {
  program
    .command("dump [targetFolder]")
    .description(
      "Generates a codebase dump. Output to Desktop or 'codebase_dumps' in project."
    )
    .option(
      "--natives",
      "Include the native android/ and ios/ folders in the dump."
    )
    .action(async (targetFolder, options) => {
      const projectRoot = process.cwd();
      try {
        await executeDump(projectRoot, targetFolder, options.natives || false);
      } catch (error) {
        console.error(`‚ùå Error during 'dump' command: ${error.message}`);
        process.exit(1);
      }
    });
}
